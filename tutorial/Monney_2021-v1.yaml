core:
  loader: flash
  beamtime_id: 11010004
  year: 2021
  beamline: pg2
  instrument: hextof
#   paths:
#     raw: "/asap3/flash/gpfs/pg2/2021/data/11010004/raw/hdf/FL1USER3/"
#     processed: "/asap3/flash/gpfs/pg2/2021/data/11010004/processed/parquet/"
  
  # The prefixes of the stream names for different DAQ systems for parsing filenames
  # (Not to be changed by user)
  stream_name_prefixes:
    pbd: "GMD_DATA_gmd_data"
    pbd2: "FL2PhotDiag_pbd2_gmd_data"
    fl1user1: "FLASH1_USER1_stream_2"
    fl1user2: "FLASH1_USER2_stream_2"
    fl1user3: "FLASH1_USER3_stream_2"
    fl2user1: "FLASH2_USER1_stream_2"
    fl2user2: "FLASH2_USER2_stream_2"

  # The beamtime directories for different DAQ systems.
  # (Not to be changed by user)
  beamtime_dir:
    pg2: "/asap3/flash/gpfs/pg2/"
    hextof: "/asap3/fs-flash-o/gpfs/hextof/"
    wespe: "/asap3/fs-flash-o/gpfs/wespe/"
  
  # Since this will run on maxwell most probably, we have a lot of cores at our disposal
  num_cores: 100


binning:
  # Histogram computation mode to use. #was numpy before v1 change
  hist_mode: "numba"
  # Mode for histogram recombination to use
  mode: fast
  # Whether to display a progress bar
  pbar: True
  # Number of multithreading threads per worker thread
  threads_per_worker: 4
  # API for numpy multithreading
  threadpool_API: "blas"

dataframe:
  daq: fl1user3                                   # DAQ system name to resolve filenames/paths
  ubid_offset: 0                                  # Offset correction to the pulseId
  forward_fill_iterations: 2                      # Number of iterations to fill the pulseId forward
  split_sector_id_from_dld_time: True             # Remove reserved bits for dldSectorID from dldTimeSteps column
  sector_id_reserved_bits: 3                      # Bits reserved for dldSectorID in the dldTimeSteps column
  sector_delays: [0., 0., 0., 0., 0., 0., 0., 0.] # Sector delays

  # Time and binning settings
  tof_binwidth: 2.0576131995767355E-11            # Base time-of-flight bin width in seconds
  tof_binning: 8                                  # Binning parameter for time-of-flight data

  # Columns used for jitter correction
  jitter_cols: [dldPosX, dldPosY, dldTimeSteps]

  # Column settings
  columns:
    x: dldPosX
    corrected_x: X
    kx: kx
    y: dldPosY
    corrected_y: Y
    ky: ky
    tof: dldTimeSteps
    tof_ns: dldTime
    corrected_tof: tm
    timestamp: timeStamp
    auxiliary: dldAux
    sector_id: dldSectorID
    delay: delayStage
    corrected_delay: pumpProbeTime

  # These are the units of the columns
  units:
    dldPosX: 'step'
    dldPosY: 'step'
    dldTimeSteps: 'step'
    tof_voltage: 'V'
    extractorVoltage: 'V'
    extractorCurrent: 'A'
    cryoTemperature: 'K'
    sampleTemperature: 'K'
    dldTime: 'ns'
    delay: 'ps'
    delayStage: 'ps'
    timeStamp: 's'
    energy: 'eV'
    E: 'eV'
    kx: '1/A'
    ky: '1/A'

  # The channels to load.
  # channels have the following structure:
  # channelAlias:
  #   format: per_pulse/per_electron/per_train
  #   group_name: the hdf5 group path
  #   slice: if the group contains multidim data, where to slice

  channels:
    # The timestamp
    timeStamp:
      format: per_train
      index_key: "/zraw/TIMINGINFO/TIME1.BUNCH_FIRST_INDEX.1/dGroup/index"
      dataset_key: "/zraw/TIMINGINFO/TIME1.BUNCH_FIRST_INDEX.1/dGroup/time"

    # pulse ID is a necessary channel for using the loader.
    pulseId:
      format: per_electron
      index_key: "/zraw/FLASH.FEL/HEXTOF.DAQ/DLD1/dGroup/index"
      dataset_key: "/zraw/FLASH.FEL/HEXTOF.DAQ/DLD1/dGroup/value"
      slice: 2
      dtype: uint16

    # detector x position
    dldPosX:
      format: per_electron
      index_key: "/zraw/FLASH.FEL/HEXTOF.DAQ/DLD1/dGroup/index"
      dataset_key: "/zraw/FLASH.FEL/HEXTOF.DAQ/DLD1/dGroup/value"
      slice: 1
      dtype: uint16

    # detector y position
    dldPosY:
      format: per_electron
      index_key: "/zraw/FLASH.FEL/HEXTOF.DAQ/DLD1/dGroup/index"
      dataset_key: "/zraw/FLASH.FEL/HEXTOF.DAQ/DLD1/dGroup/value"
      slice: 0
      dtype: uint16

    # Detector time-of-flight channel
    # if split_sector_id_from_dld_time is set to True, This this will generate
    # also the dldSectorID channel
    dldTimeSteps:
      format: per_electron
      index_key: "/zraw/FLASH.FEL/HEXTOF.DAQ/DLD1/dGroup/index"
      dataset_key: "/zraw/FLASH.FEL/HEXTOF.DAQ/DLD1/dGroup/value"
      slice: 3
      dtype: uint32

    # The auxillary channel has a special structure where the group further contains
    # a multidim structure so further aliases are defined below
    dldAux:
      format: per_train
      index_key: "/zraw/FLASH.FEL/HEXTOF.DAQ/DLD1/dGroup/index"
      dataset_key: "/zraw/FLASH.FEL/HEXTOF.DAQ/DLD1/dGroup/value"
      slice: 4
      sub_channels:
        sampleBias:
          slice: 0
          dtype: float32
        tofVoltage:
          slice: 1
          dtype: float64
        extractorVoltage:
          slice: 2
        extractorCurrent:
          slice: 3
        cryoTemperature:
          slice: 4
        sampleTemperature:
          slice: 5
        dldTimeBinSize:
          slice: 15


    # the energy of the monochromatized beam. This is a quasi-static value.
    # there is a better channel which still needs implementation.
    monochromatorPhotonEnergy:
      format: per_train
      index_key: "/FL1/Beamlines/PG/Monochromator/monochromator photon energy/index"
      dataset_key: "/FL1/Beamlines/PG/Monochromator/monochromator photon energy/value"


#     gmdBda:
#       format: per_train
#       index_key: "/FL1/Photon Diagnostic/GMD/Average energy/energy BDA/index"
#       dataset_key: "/FL1/Photon Diagnostic/GMD/Average energy/energy BDA/value"

    bam:
      format: per_pulse
      index_key: "/zraw/FLASH.SDIAG/BAM.DAQ/4DBC3.HIGH_CHARGE_ARRIVAL_TIME/dGroup/index"
      dataset_key: "/zraw/FLASH.SDIAG/BAM.DAQ/4DBC3.HIGH_CHARGE_ARRIVAL_TIME/dGroup/value"
      

    # The delay Stage position, encoding the pump-probe delay
    delayStage:
      format: per_train
      index_key: "/zraw/FLASH.SYNC/LASER.LOCK.EXP/FLASH1.MOD1.PG.OSC/FMC0.MD22.1.ENCODER_POSITION.RD/dGroup/index"
      dataset_key: "/zraw/FLASH.SYNC/LASER.LOCK.EXP/FLASH1.MOD1.PG.OSC/FMC0.MD22.1.ENCODER_POSITION.RD/dGroup/value"

    opticalDiode:
      format: per_train
      index_key: "/uncategorised/FLASH.LASER/FLACPUPGLASER1.PULSEENERGY/PG2_incoupl/PULSEENERGY.MEAN/index"
      dataset_key: "/uncategorised/FLASH.LASER/FLACPUPGLASER1.PULSEENERGY/PG2_incoupl/PULSEENERGY.MEAN/value"
      # group_name: "/zraw/FLASH.LASER/FLACPUPGLASER1.PULSEENERGY/PG2_incoupl/dGroup/"


    # # ADC containing the pulser sign (1: value approx. 35000, 0: 33000)
    # pulserSignAdc:
    #   format: per_pulse
    #   group_name: "/FL1/Experiment/PG/SIS8300 100MHz ADC/CH6/TD/"
    # gmdTunnel:
    #   format: per_pulse
    #   group_name: "/FL1/Photon Diagnostic/GMD/Pulse resolved energy/energy tunnel/"
    # Beam Arrival Monitor, vital for pump-probe experiments as it can compensate sase
    # timing fluctuations.
    # Here we use the DBC2 BAM as the "normal" one is broken.
    # gmdBdaPulse:
    #   format: per_pulse
      # group_name: "/FL1/Photon Diagnostic/GMD/Pulse resolved energy/energy BDA/"

metadata:
  archiver_url: "https://scicat-flash-test1.desy.de/api/v3"
#   token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI2Mzc0YmYyMmE4NWQ0N2QwMGE5MWRlN2MiLCJ1c2VybmFtZSI6Imt1dG55YWtkIiwiZW1haWwiOiJkbXl0cm8ua3V0bnlha2hvdkBkZXN5LmRlIiwiYXV0aFN0cmF0ZWd5IjoibG9jYWwiLCJpZCI6IjYzNzRiZjIyYTg1ZDQ3ZDAwYTkxZGU3YyIsInVzZXJJZCI6IjYzNzRiZjIyYTg1ZDQ3ZDAwYTkxZGU3YyIsImlhdCI6MTcyODU1MDc5NCwiZXhwIjoxNzI4NTkzOTk0fQ.Hqy6ICvBBMLMq8KwCLf-5tRsA-BdWGfMCR9mjWv4ldU"

nexus:
  reader: "mpes"
  definition: "NXmpes"
  input_files: ["/home/kutnyakd/sed_v1/sed/src/sed/config/NXmpes_config-HEXTOF.json"]

energy:
  calibration:
    E0: -55.01015850430491
    creation_date: 1720623305.68682
    d: 0.8972862611832251
    energy_scale: kinetic
    t0: 3.816541284431297e-07

delay:
  offsets:
    flip_delay_axis: True
    constant: -3545.3
    columns:
      bam:
        weight: -0.001
        preserve_mean: False
